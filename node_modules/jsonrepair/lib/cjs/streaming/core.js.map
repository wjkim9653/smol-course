{"version":3,"file":"core.js","names":["_JSONRepairError","require","_stringUtils","_InputBuffer","_OutputBuffer","_stack","controlCharacters","escapeCharacters","b","f","n","r","t","jsonrepairCore","_ref","onData","bufferSize","chunkSize","input","createInputBuffer","output","createOutputBuffer","write","i","iFlushed","stack","createStack","flushInputBuffer","flush","transform","chunk","push","currentLength","parse","close","parseWhitespaceAndSkipComments","type","StackType","object","caret","Caret","beforeKey","skipEllipsis","parseObjectKey","parseUnexpectedColon","parseRepairTrailingComma","parseRepairObjectEndOrComma","beforeValue","parseValue","parseRepairMissingObjectValue","afterValue","parseObjectComma","parseObjectEnd","array","parseRepairArrayEnd","parseArrayComma","parseArrayEnd","parseRepairMissingComma","ndJson","parseRepairNdJsonEnd","functionCall","parseFunctionCallEnd","root","parseRootStart","parseRootEnd","parseObjectStart","parseArrayStart","parseString","parseNumber","parseKeywords","parseRepairUnquotedString","parseRepairRegex","parseCharacter","skipCharacter","update","j","isFunctionNameCharStart","charAt","isEnd","isFunctionNameChar","k","isWhitespace","findNextDelimiter","regexUrlStart","test","substring","regexUrlChar","symbol","JSON","stringify","start","endsWithIgnoringWhitespace","stripLastOccurrence","throwObjectKeyExpected","parseUnexpectedEnd","throwUnexpectedEnd","throwUnexpectedCharacter","parsedKey","parseUnquotedKey","truncatedText","isStartOfValue","insertBeforeLastWhitespace","throwColonExpected","pop","parseMarkdownCodeBlock","parsedComma","unshift","skipNewline","arguments","length","undefined","changed","parseWhitespace","parseComment","_isWhiteSpace","isWhitespaceExceptNewline","whitespace","isSpecialWhitespace","atEndOfBlockComment","blocks","skipMarkdownCodeBlock","block","end","char","skipEscapeCharacter","stopAtDelimiter","stopAtIndex","skipEscapeChars","isQuote","isEndQuote","isDoubleQuote","isSingleQuote","isSingleQuoteLike","isDoubleQuoteLike","iBefore","oBefore","iPrev","prevNonWhitespaceIndex","isDelimiter","remove","iQuote","oQuote","isDigit","parseConcatenatedString","iPrevChar","prevChar","insertAt","isUnquotedStringDelimiter","escapeChar","isHex","throwInvalidUnicodeCharacter","isControlCharacter","isValidStringCharacter","throwInvalidCharacter","parsed","parsedStr","atEndOfNumber","repairNumberEndingWithNumericSymbol","num","hasInvalidLeadingZero","parseKeyword","name","value","isKey","prev","JSONRepairError","chars"],"sources":["../../../src/streaming/core.ts"],"sourcesContent":["import { JSONRepairError } from '../utils/JSONRepairError.js'\nimport {\n  isControlCharacter,\n  isDelimiter,\n  isDigit,\n  isDoubleQuote,\n  isDoubleQuoteLike,\n  isFunctionNameChar,\n  isFunctionNameCharStart,\n  isHex,\n  isQuote,\n  isSingleQuote,\n  isSingleQuoteLike,\n  isSpecialWhitespace,\n  isStartOfValue,\n  isUnquotedStringDelimiter,\n  isValidStringCharacter,\n  isWhitespace,\n  isWhitespaceExceptNewline,\n  regexUrlChar,\n  regexUrlStart\n} from '../utils/stringUtils.js'\nimport { createInputBuffer } from './buffer/InputBuffer.js'\nimport { createOutputBuffer } from './buffer/OutputBuffer.js'\nimport { Caret, createStack, StackType } from './stack.js'\n\nconst controlCharacters: { [key: string]: string } = {\n  '\\b': '\\\\b',\n  '\\f': '\\\\f',\n  '\\n': '\\\\n',\n  '\\r': '\\\\r',\n  '\\t': '\\\\t'\n}\n\n// map with all escape characters\nconst escapeCharacters: { [key: string]: string } = {\n  '\"': '\"',\n  '\\\\': '\\\\',\n  '/': '/',\n  b: '\\b',\n  f: '\\f',\n  n: '\\n',\n  r: '\\r',\n  t: '\\t'\n  // note that \\u is handled separately in parseString()\n}\n\nexport interface JsonRepairCoreOptions {\n  onData: (chunk: string) => void\n  chunkSize?: number\n  bufferSize?: number\n}\n\nexport interface JsonRepairCore {\n  transform: (chunk: string) => void\n  flush: () => void\n}\n\nexport function jsonrepairCore({\n  onData,\n  bufferSize = 65536,\n  chunkSize = 65536\n}: JsonRepairCoreOptions): JsonRepairCore {\n  const input = createInputBuffer()\n\n  const output = createOutputBuffer({\n    write: onData,\n    bufferSize,\n    chunkSize\n  })\n\n  let i = 0\n  let iFlushed = 0\n  const stack = createStack()\n\n  function flushInputBuffer() {\n    while (iFlushed < i - bufferSize - chunkSize) {\n      iFlushed += chunkSize\n      input.flush(iFlushed)\n    }\n  }\n\n  function transform(chunk: string) {\n    input.push(chunk)\n\n    while (i < input.currentLength() - bufferSize && parse()) {\n      // loop until there is nothing more to process\n    }\n\n    flushInputBuffer()\n  }\n\n  function flush() {\n    input.close()\n\n    while (parse()) {\n      // loop until there is nothing more to process\n    }\n\n    output.flush()\n  }\n\n  function parse(): boolean {\n    parseWhitespaceAndSkipComments()\n\n    switch (stack.type) {\n      case StackType.object: {\n        switch (stack.caret) {\n          case Caret.beforeKey:\n            return (\n              skipEllipsis() ||\n              parseObjectKey() ||\n              parseUnexpectedColon() ||\n              parseRepairTrailingComma() ||\n              parseRepairObjectEndOrComma()\n            )\n          case Caret.beforeValue:\n            return parseValue() || parseRepairMissingObjectValue()\n          case Caret.afterValue:\n            return parseObjectComma() || parseObjectEnd() || parseRepairObjectEndOrComma()\n          default:\n            return false\n        }\n      }\n\n      case StackType.array: {\n        switch (stack.caret) {\n          case Caret.beforeValue:\n            return (\n              skipEllipsis() || parseValue() || parseRepairTrailingComma() || parseRepairArrayEnd()\n            )\n          case Caret.afterValue:\n            return (\n              parseArrayComma() ||\n              parseArrayEnd() ||\n              parseRepairMissingComma() ||\n              parseRepairArrayEnd()\n            )\n          default:\n            return false\n        }\n      }\n\n      case StackType.ndJson: {\n        switch (stack.caret) {\n          case Caret.beforeValue:\n            return parseValue() || parseRepairTrailingComma()\n          case Caret.afterValue:\n            return parseArrayComma() || parseRepairMissingComma() || parseRepairNdJsonEnd()\n          default:\n            return false\n        }\n      }\n\n      case StackType.functionCall: {\n        switch (stack.caret) {\n          case Caret.beforeValue:\n            return parseValue()\n          case Caret.afterValue:\n            return parseFunctionCallEnd()\n          default:\n            return false\n        }\n      }\n\n      case StackType.root: {\n        switch (stack.caret) {\n          case Caret.beforeValue:\n            return parseRootStart()\n          case Caret.afterValue:\n            return parseRootEnd()\n          default:\n            return false\n        }\n      }\n\n      default:\n        return false\n    }\n  }\n\n  function parseValue(): boolean {\n    return (\n      parseObjectStart() ||\n      parseArrayStart() ||\n      parseString() ||\n      parseNumber() ||\n      parseKeywords() ||\n      parseRepairUnquotedString() ||\n      parseRepairRegex()\n    )\n  }\n\n  function parseObjectStart(): boolean {\n    if (parseCharacter('{')) {\n      parseWhitespaceAndSkipComments()\n\n      skipEllipsis()\n\n      if (skipCharacter(',')) {\n        parseWhitespaceAndSkipComments()\n      }\n\n      if (parseCharacter('}')) {\n        return stack.update(Caret.afterValue)\n      }\n\n      return stack.push(StackType.object, Caret.beforeKey)\n    }\n\n    return false\n  }\n\n  function parseArrayStart(): boolean {\n    if (parseCharacter('[')) {\n      parseWhitespaceAndSkipComments()\n\n      skipEllipsis()\n\n      if (skipCharacter(',')) {\n        parseWhitespaceAndSkipComments()\n      }\n\n      if (parseCharacter(']')) {\n        return stack.update(Caret.afterValue)\n      }\n\n      return stack.push(StackType.array, Caret.beforeValue)\n    }\n\n    return false\n  }\n\n  function parseRepairUnquotedString(): boolean {\n    let j = i\n\n    if (isFunctionNameCharStart(input.charAt(j))) {\n      while (!input.isEnd(j) && isFunctionNameChar(input.charAt(j))) {\n        j++\n      }\n\n      let k = j\n      while (isWhitespace(input, k)) {\n        k++\n      }\n\n      if (input.charAt(k) === '(') {\n        // repair a MongoDB function call like NumberLong(\"2\")\n        // repair a JSONP function call like callback({...});\n        k++\n        i = k\n        return stack.push(StackType.functionCall, Caret.beforeValue)\n      }\n    }\n\n    j = findNextDelimiter(false, j)\n    if (j !== null) {\n      // test start of an url like \"https://...\" (this would be parsed as a comment)\n      if (input.charAt(j - 1) === ':' && regexUrlStart.test(input.substring(i, j + 2))) {\n        while (!input.isEnd(j) && regexUrlChar.test(input.charAt(j))) {\n          j++\n        }\n      }\n\n      const symbol = input.substring(i, j)\n      i = j\n\n      output.push(symbol === 'undefined' ? 'null' : JSON.stringify(symbol))\n\n      if (input.charAt(i) === '\"') {\n        // we had a missing start quote, but now we encountered the end quote, so we can skip that one\n        i++\n      }\n\n      return stack.update(Caret.afterValue)\n    }\n\n    return false\n  }\n\n  function parseRepairRegex() {\n    if (input.charAt(i) === '/') {\n      const start = i\n      i++\n\n      while (!input.isEnd(i) && (input.charAt(i) !== '/' || input.charAt(i - 1) === '\\\\')) {\n        i++\n      }\n      i++\n\n      output.push(`\"${input.substring(start, i)}\"`)\n\n      return stack.update(Caret.afterValue)\n    }\n  }\n\n  function parseRepairMissingObjectValue(): boolean {\n    // repair missing object value\n    output.push('null')\n    return stack.update(Caret.afterValue)\n  }\n\n  function parseRepairTrailingComma(): boolean {\n    // repair trailing comma\n    if (output.endsWithIgnoringWhitespace(',')) {\n      output.stripLastOccurrence(',')\n      return stack.update(Caret.afterValue)\n    }\n\n    return false\n  }\n\n  function parseUnexpectedColon(): boolean {\n    if (input.charAt(i) === ':') {\n      throwObjectKeyExpected()\n    }\n\n    return false\n  }\n\n  function parseUnexpectedEnd(): boolean {\n    if (input.isEnd(i)) {\n      throwUnexpectedEnd()\n    } else {\n      throwUnexpectedCharacter()\n    }\n\n    return false\n  }\n\n  function parseObjectKey(): boolean {\n    const parsedKey = parseString() || parseUnquotedKey()\n    if (parsedKey) {\n      parseWhitespaceAndSkipComments()\n\n      if (parseCharacter(':')) {\n        // expect a value after the :\n        return stack.update(Caret.beforeValue)\n      }\n\n      const truncatedText = input.isEnd(i)\n      if (isStartOfValue(input.charAt(i)) || truncatedText) {\n        // repair missing colon\n        output.insertBeforeLastWhitespace(':')\n        return stack.update(Caret.beforeValue)\n      }\n\n      throwColonExpected()\n    }\n\n    return false\n  }\n\n  function parseObjectComma(): boolean {\n    if (parseCharacter(',')) {\n      return stack.update(Caret.beforeKey)\n    }\n\n    return false\n  }\n\n  function parseObjectEnd(): boolean {\n    if (parseCharacter('}')) {\n      return stack.pop()\n    }\n\n    return false\n  }\n\n  function parseRepairObjectEndOrComma(): true {\n    // repair missing object end and trailing comma\n    if (input.charAt(i) === '{') {\n      output.stripLastOccurrence(',')\n      output.insertBeforeLastWhitespace('}')\n      return stack.pop()\n    }\n\n    // repair missing comma\n    if (!input.isEnd(i) && isStartOfValue(input.charAt(i))) {\n      output.insertBeforeLastWhitespace(',')\n      return stack.update(Caret.beforeKey)\n    }\n\n    // repair missing closing brace\n    output.insertBeforeLastWhitespace('}')\n    return stack.pop()\n  }\n\n  function parseArrayComma(): boolean {\n    if (parseCharacter(',')) {\n      return stack.update(Caret.beforeValue)\n    }\n\n    return false\n  }\n\n  function parseArrayEnd(): boolean {\n    if (parseCharacter(']')) {\n      return stack.pop()\n    }\n\n    return false\n  }\n\n  function parseRepairMissingComma(): boolean {\n    // repair missing comma\n    if (!input.isEnd(i) && isStartOfValue(input.charAt(i))) {\n      output.insertBeforeLastWhitespace(',')\n      return stack.update(Caret.beforeValue)\n    }\n\n    return false\n  }\n\n  function parseRepairArrayEnd(): true {\n    // repair missing closing bracket\n    output.insertBeforeLastWhitespace(']')\n    return stack.pop()\n  }\n\n  function parseRepairNdJsonEnd(): boolean {\n    if (input.isEnd(i)) {\n      output.push('\\n]')\n      return stack.pop()\n    }\n\n    throwUnexpectedEnd()\n    return false // just to make TS happy\n  }\n\n  function parseFunctionCallEnd(): true {\n    if (skipCharacter(')')) {\n      skipCharacter(';')\n    }\n\n    return stack.pop()\n  }\n\n  function parseRootStart(): boolean {\n    parseMarkdownCodeBlock(['```', '[```', '{```'])\n\n    return parseValue() || parseUnexpectedEnd()\n  }\n\n  function parseRootEnd(): boolean {\n    parseMarkdownCodeBlock(['```', '```]', '```}'])\n\n    const parsedComma = parseCharacter(',')\n    parseWhitespaceAndSkipComments()\n\n    if (\n      isStartOfValue(input.charAt(i)) &&\n      (output.endsWithIgnoringWhitespace(',') || output.endsWithIgnoringWhitespace('\\n'))\n    ) {\n      // start of a new value after end of the root level object: looks like\n      // newline delimited JSON -> turn into a root level array\n      if (!parsedComma) {\n        // repair missing comma\n        output.insertBeforeLastWhitespace(',')\n      }\n\n      output.unshift('[\\n')\n\n      return stack.push(StackType.ndJson, Caret.beforeValue)\n    }\n\n    if (parsedComma) {\n      // repair: remove trailing comma\n      output.stripLastOccurrence(',')\n\n      return stack.update(Caret.afterValue)\n    }\n\n    // repair redundant end braces and brackets\n    while (input.charAt(i) === '}' || input.charAt(i) === ']') {\n      i++\n      parseWhitespaceAndSkipComments()\n    }\n\n    if (!input.isEnd(i)) {\n      throwUnexpectedCharacter()\n    }\n\n    return false\n  }\n\n  function parseWhitespaceAndSkipComments(skipNewline = true): boolean {\n    const start = i\n\n    let changed = parseWhitespace(skipNewline)\n    do {\n      changed = parseComment()\n      if (changed) {\n        changed = parseWhitespace(skipNewline)\n      }\n    } while (changed)\n\n    return i > start\n  }\n\n  function parseWhitespace(skipNewline: boolean): boolean {\n    const _isWhiteSpace = skipNewline ? isWhitespace : isWhitespaceExceptNewline\n    let whitespace = ''\n\n    while (true) {\n      if (_isWhiteSpace(input, i)) {\n        whitespace += input.charAt(i)\n        i++\n      } else if (isSpecialWhitespace(input, i)) {\n        // repair special whitespace\n        whitespace += ' '\n        i++\n      } else {\n        break\n      }\n    }\n\n    if (whitespace.length > 0) {\n      output.push(whitespace)\n      return true\n    }\n\n    return false\n  }\n\n  function parseComment(): boolean {\n    // find a block comment '/* ... */'\n    if (input.charAt(i) === '/' && input.charAt(i + 1) === '*') {\n      // repair block comment by skipping it\n      while (!input.isEnd(i) && !atEndOfBlockComment(i)) {\n        i++\n      }\n      i += 2\n\n      return true\n    }\n\n    // find a line comment '// ...'\n    if (input.charAt(i) === '/' && input.charAt(i + 1) === '/') {\n      // repair line comment by skipping it\n      while (!input.isEnd(i) && input.charAt(i) !== '\\n') {\n        i++\n      }\n\n      return true\n    }\n\n    return false\n  }\n\n  function parseMarkdownCodeBlock(blocks: string[]): boolean {\n    // find and skip over a Markdown fenced code block:\n    //     ``` ... ```\n    // or\n    //     ```json ... ```\n    if (skipMarkdownCodeBlock(blocks)) {\n      if (isFunctionNameCharStart(input.charAt(i))) {\n        // strip the optional language specifier like \"json\"\n        while (!input.isEnd(i) && isFunctionNameChar(input.charAt(i))) {\n          i++\n        }\n      }\n\n      parseWhitespaceAndSkipComments()\n\n      return true\n    }\n\n    return false\n  }\n\n  function skipMarkdownCodeBlock(blocks: string[]): boolean {\n    for (const block of blocks) {\n      const end = i + block.length\n      if (input.substring(i, end) === block) {\n        i = end\n        return true\n      }\n    }\n\n    return false\n  }\n\n  function parseCharacter(char: string): boolean {\n    if (input.charAt(i) === char) {\n      output.push(input.charAt(i))\n      i++\n      return true\n    }\n\n    return false\n  }\n\n  function skipCharacter(char: string): boolean {\n    if (input.charAt(i) === char) {\n      i++\n      return true\n    }\n\n    return false\n  }\n\n  function skipEscapeCharacter(): boolean {\n    return skipCharacter('\\\\')\n  }\n\n  /**\n   * Skip ellipsis like \"[1,2,3,...]\" or \"[1,2,3,...,9]\" or \"[...,7,8,9]\"\n   * or a similar construct in objects.\n   */\n  function skipEllipsis(): boolean {\n    parseWhitespaceAndSkipComments()\n\n    if (input.charAt(i) === '.' && input.charAt(i + 1) === '.' && input.charAt(i + 2) === '.') {\n      // repair: remove the ellipsis (three dots) and optionally a comma\n      i += 3\n      parseWhitespaceAndSkipComments()\n      skipCharacter(',')\n\n      return true\n    }\n\n    return false\n  }\n\n  /**\n   * Parse a string enclosed by double quotes \"...\". Can contain escaped quotes\n   * Repair strings enclosed in single quotes or special quotes\n   * Repair an escaped string\n   *\n   * The function can run in two stages:\n   * - First, it assumes the string has a valid end quote\n   * - If it turns out that the string does not have a valid end quote followed\n   *   by a delimiter (which should be the case), the function runs again in a\n   *   more conservative way, stopping the string at the first next delimiter\n   *   and fixing the string by inserting a quote there, or stopping at a\n   *   stop index detected in the first iteration.\n   */\n  function parseString(stopAtDelimiter = false, stopAtIndex = -1): boolean {\n    let skipEscapeChars = input.charAt(i) === '\\\\'\n    if (skipEscapeChars) {\n      // repair: remove the first escape character\n      i++\n      skipEscapeChars = true\n    }\n\n    if (isQuote(input.charAt(i))) {\n      // double quotes are correct JSON,\n      // single quotes come from JavaScript for example, we assume it will have a correct single end quote too\n      // otherwise, we will match any double-quote-like start with a double-quote-like end,\n      // or any single-quote-like start with a single-quote-like end\n      const isEndQuote = isDoubleQuote(input.charAt(i))\n        ? isDoubleQuote\n        : isSingleQuote(input.charAt(i))\n          ? isSingleQuote\n          : isSingleQuoteLike(input.charAt(i))\n            ? isSingleQuoteLike\n            : isDoubleQuoteLike\n\n      const iBefore = i\n      const oBefore = output.length()\n\n      output.push('\"')\n      i++\n\n      while (true) {\n        if (input.isEnd(i)) {\n          // end of text, we have a missing quote somewhere\n\n          const iPrev = prevNonWhitespaceIndex(i - 1)\n          if (!stopAtDelimiter && isDelimiter(input.charAt(iPrev))) {\n            // if the text ends with a delimiter, like [\"hello],\n            // so the missing end quote should be inserted before this delimiter\n            // retry parsing the string, stopping at the first next delimiter\n            i = iBefore\n            output.remove(oBefore)\n\n            return parseString(true)\n          }\n\n          // repair missing quote\n          output.insertBeforeLastWhitespace('\"')\n\n          return stack.update(Caret.afterValue)\n        }\n\n        if (i === stopAtIndex) {\n          // use the stop index detected in the first iteration, and repair end quote\n          output.insertBeforeLastWhitespace('\"')\n\n          return stack.update(Caret.afterValue)\n        }\n\n        if (isEndQuote(input.charAt(i))) {\n          // end quote\n          // let us check what is before and after the quote to verify whether this is a legit end quote\n          const iQuote = i\n          const oQuote = output.length()\n          output.push('\"')\n          i++\n\n          parseWhitespaceAndSkipComments(false)\n\n          if (\n            stopAtDelimiter ||\n            input.isEnd(i) ||\n            isDelimiter(input.charAt(i)) ||\n            isQuote(input.charAt(i)) ||\n            isDigit(input.charAt(i))\n          ) {\n            // The quote is followed by the end of the text, a delimiter, or a next value\n            // so the quote is indeed the end of the string\n            parseConcatenatedString()\n\n            return stack.update(Caret.afterValue)\n          }\n\n          const iPrevChar = prevNonWhitespaceIndex(iQuote - 1)\n          const prevChar = input.charAt(iPrevChar)\n\n          if (prevChar === ',') {\n            // A comma followed by a quote, like '{\"a\":\"b,c,\"d\":\"e\"}'.\n            // We assume that the quote is a start quote, and that the end quote\n            // should have been located right before the comma but is missing.\n            i = iBefore\n            output.remove(oBefore)\n\n            return parseString(false, iPrevChar)\n          }\n\n          if (isDelimiter(prevChar)) {\n            // This is not the right end quote: it is preceded by a delimiter,\n            // and NOT followed by a delimiter. So, there is an end quote missing\n            // parse the string again and then stop at the first next delimiter\n            i = iBefore\n            output.remove(oBefore)\n\n            return parseString(true)\n          }\n\n          // revert to right after the quote but before any whitespace, and continue parsing the string\n          output.remove(oQuote + 1)\n          i = iQuote + 1\n\n          // repair unescaped quote\n          output.insertAt(oQuote, '\\\\')\n        } else if (stopAtDelimiter && isUnquotedStringDelimiter(input.charAt(i))) {\n          // we're in the mode to stop the string at the first delimiter\n          // because there is an end quote missing\n\n          // test start of an url like \"https://...\" (this would be parsed as a comment)\n          if (\n            input.charAt(i - 1) === ':' &&\n            regexUrlStart.test(input.substring(iBefore + 1, i + 2))\n          ) {\n            while (!input.isEnd(i) && regexUrlChar.test(input.charAt(i))) {\n              output.push(input.charAt(i))\n              i++\n            }\n          }\n\n          // repair missing quote\n          output.insertBeforeLastWhitespace('\"')\n\n          parseConcatenatedString()\n\n          return stack.update(Caret.afterValue)\n        } else if (input.charAt(i) === '\\\\') {\n          // handle escaped content like \\n or \\u2605\n          const char = input.charAt(i + 1)\n          const escapeChar = escapeCharacters[char]\n          if (escapeChar !== undefined) {\n            output.push(input.substring(i, i + 2))\n            i += 2\n          } else if (char === 'u') {\n            let j = 2\n            while (j < 6 && isHex(input.charAt(i + j))) {\n              j++\n            }\n\n            if (j === 6) {\n              output.push(input.substring(i, i + 6))\n              i += 6\n            } else if (input.isEnd(i + j)) {\n              // repair invalid or truncated unicode char at the end of the text\n              // by removing the unicode char and ending the string here\n              i += j\n            } else {\n              throwInvalidUnicodeCharacter()\n            }\n          } else {\n            // repair invalid escape character: remove it\n            output.push(char)\n            i += 2\n          }\n        } else {\n          // handle regular characters\n          const char = input.charAt(i)\n\n          if (char === '\"' && input.charAt(i - 1) !== '\\\\') {\n            // repair unescaped double quote\n            output.push(`\\\\${char}`)\n            i++\n          } else if (isControlCharacter(char)) {\n            // unescaped control character\n            output.push(controlCharacters[char])\n            i++\n          } else {\n            if (!isValidStringCharacter(char)) {\n              throwInvalidCharacter(char)\n            }\n            output.push(char)\n            i++\n          }\n        }\n\n        if (skipEscapeChars) {\n          // repair: skipped escape character (nothing to do)\n          skipEscapeCharacter()\n        }\n      }\n    }\n\n    return false\n  }\n\n  /**\n   * Repair concatenated strings like \"hello\" + \"world\", change this into \"helloworld\"\n   */\n  function parseConcatenatedString(): boolean {\n    let parsed = false\n\n    parseWhitespaceAndSkipComments()\n    while (input.charAt(i) === '+') {\n      parsed = true\n      i++\n      parseWhitespaceAndSkipComments()\n\n      // repair: remove the end quote of the first string\n      output.stripLastOccurrence('\"', true)\n      const start = output.length()\n      const parsedStr = parseString()\n      if (parsedStr) {\n        // repair: remove the start quote of the second string\n        output.remove(start, start + 1)\n      } else {\n        // repair: remove the + because it is not followed by a string\n        output.insertBeforeLastWhitespace('\"')\n      }\n    }\n\n    return parsed\n  }\n\n  /**\n   * Parse a number like 2.4 or 2.4e6\n   */\n  function parseNumber(): boolean {\n    const start = i\n    if (input.charAt(i) === '-') {\n      i++\n      if (atEndOfNumber()) {\n        repairNumberEndingWithNumericSymbol(start)\n        return stack.update(Caret.afterValue)\n      }\n      if (!isDigit(input.charAt(i))) {\n        i = start\n        return false\n      }\n    }\n\n    // Note that in JSON leading zeros like \"00789\" are not allowed.\n    // We will allow all leading zeros here though and at the end of parseNumber\n    // check against trailing zeros and repair that if needed.\n    // Leading zeros can have meaning, so we should not clear them.\n    while (isDigit(input.charAt(i))) {\n      i++\n    }\n\n    if (input.charAt(i) === '.') {\n      i++\n      if (atEndOfNumber()) {\n        repairNumberEndingWithNumericSymbol(start)\n        return stack.update(Caret.afterValue)\n      }\n      if (!isDigit(input.charAt(i))) {\n        i = start\n        return false\n      }\n      while (isDigit(input.charAt(i))) {\n        i++\n      }\n    }\n\n    if (input.charAt(i) === 'e' || input.charAt(i) === 'E') {\n      i++\n      if (input.charAt(i) === '-' || input.charAt(i) === '+') {\n        i++\n      }\n      if (atEndOfNumber()) {\n        repairNumberEndingWithNumericSymbol(start)\n        return stack.update(Caret.afterValue)\n      }\n      if (!isDigit(input.charAt(i))) {\n        i = start\n        return false\n      }\n      while (isDigit(input.charAt(i))) {\n        i++\n      }\n    }\n\n    // if we're not at the end of the number by this point, allow this to be parsed as another type\n    if (!atEndOfNumber()) {\n      i = start\n      return false\n    }\n\n    if (i > start) {\n      // repair a number with leading zeros like \"00789\"\n      const num = input.substring(start, i)\n      const hasInvalidLeadingZero = /^0\\d/.test(num)\n\n      output.push(hasInvalidLeadingZero ? `\"${num}\"` : num)\n      return stack.update(Caret.afterValue)\n    }\n\n    return false\n  }\n\n  /**\n   * Parse keywords true, false, null\n   * Repair Python keywords True, False, None\n   */\n  function parseKeywords(): boolean {\n    return (\n      parseKeyword('true', 'true') ||\n      parseKeyword('false', 'false') ||\n      parseKeyword('null', 'null') ||\n      // repair Python keywords True, False, None\n      parseKeyword('True', 'true') ||\n      parseKeyword('False', 'false') ||\n      parseKeyword('None', 'null')\n    )\n  }\n\n  function parseKeyword(name: string, value: string): boolean {\n    if (input.substring(i, i + name.length) === name) {\n      output.push(value)\n      i += name.length\n      return stack.update(Caret.afterValue)\n    }\n\n    return false\n  }\n\n  function parseUnquotedKey(): boolean {\n    let end = findNextDelimiter(true, i)\n\n    if (end !== null) {\n      // first, go back to prevent getting trailing whitespaces in the string\n      while (isWhitespace(input, end - 1) && end > i) {\n        end--\n      }\n\n      const symbol = input.substring(i, end)\n      output.push(JSON.stringify(symbol))\n      i = end\n\n      if (input.charAt(i) === '\"') {\n        // we had a missing start quote, but now we encountered the end quote, so we can skip that one\n        i++\n      }\n\n      return stack.update(Caret.afterValue) // we do not have a state Caret.afterKey, therefore we use afterValue here\n    }\n\n    return false\n  }\n\n  function findNextDelimiter(isKey: boolean, start: number): number | null {\n    // note that the symbol can end with whitespaces: we stop at the next delimiter\n    // also, note that we allow strings to contain a slash / in order to support repairing regular expressions\n    let j = start\n    while (\n      !input.isEnd(j) &&\n      !isUnquotedStringDelimiter(input.charAt(j)) &&\n      !isQuote(input.charAt(j)) &&\n      (!isKey || input.charAt(j) !== ':')\n    ) {\n      j++\n    }\n\n    return j > i ? j : null\n  }\n\n  function prevNonWhitespaceIndex(start: number): number {\n    let prev = start\n\n    while (prev > 0 && isWhitespace(input, prev)) {\n      prev--\n    }\n\n    return prev\n  }\n\n  function atEndOfNumber() {\n    return input.isEnd(i) || isDelimiter(input.charAt(i)) || isWhitespace(input, i)\n  }\n\n  function repairNumberEndingWithNumericSymbol(start: number) {\n    // repair numbers cut off at the end\n    // this will only be called when we end after a '.', '-', or 'e' and does not\n    // change the number more than it needs to make it valid JSON\n    output.push(`${input.substring(start, i)}0`)\n  }\n\n  function throwInvalidCharacter(char: string) {\n    throw new JSONRepairError(`Invalid character ${JSON.stringify(char)}`, i)\n  }\n\n  function throwUnexpectedCharacter() {\n    throw new JSONRepairError(`Unexpected character ${JSON.stringify(input.charAt(i))}`, i)\n  }\n\n  function throwUnexpectedEnd() {\n    throw new JSONRepairError('Unexpected end of json string', i)\n  }\n\n  function throwObjectKeyExpected() {\n    throw new JSONRepairError('Object key expected', i)\n  }\n\n  function throwColonExpected() {\n    throw new JSONRepairError('Colon expected', i)\n  }\n\n  function throwInvalidUnicodeCharacter() {\n    const chars = input.substring(i, i + 6)\n    throw new JSONRepairError(`Invalid unicode character \"${chars}\"`, i)\n  }\n\n  function atEndOfBlockComment(i: number) {\n    return input.charAt(i) === '*' && input.charAt(i + 1) === '/'\n  }\n\n  return {\n    transform,\n    flush\n  }\n}\n"],"mappings":"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","ignoreList":[]}